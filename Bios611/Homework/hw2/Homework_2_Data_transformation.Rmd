---
  title: "BIOS 611 HW2 Data transformation (Chapter 5)"
  author: "(Ty Darnell)"
  date: "`r format(Sys.time(), '%m/%d/%Y')`"
  output: html_document
---
##### Due Date: 09/10/18 (6pm)

  This set of exercise is taken from R for Data Science by Garrett Grolemund and Hadley Wickham but modified slightly for the purpose of this class.

# Exercise 1

Note that the dataset `flights` is from the package `nycflights13`

1.  Find all flights that (Shows all the rows with the following characteristics. Then for each problem, make a variable called 'ans.flight.i' where 'i' is replaced by the subproblem number(1,2,3,...) containing all these rows.)

```{r setup, include=FALSE}
library(tidyverse)
library(nycflights13)
```

    1. Had an arrival delay of two or more hours
```{r} 
ans.flight.1=filter(flights,arr_delay>=120)
```

    1. Flew to Houston (`IAH` or `HOU`)
```{r}
ans.flight.2=filter(flights,dest %in% c('IAH','HOU'))
```

    1. Were operated by United, American, or Delta
```{r}
ans.flight.3=filter(flights,carrier %in% c('AA','DL','UA'))
```

    1. Departed in summer (July, August, and September)
```{r}
ans.flight.4=filter(flights,month %in% c(7,8,9))
```

    1. Arrived more than two hours late, but didn't leave late
```{r}
ans.flight.5=filter(flights,arr_delay>120,dep_delay<=0)
```

    1. Were delayed by at least an hour, but made up over 30 minutes in flight
```{r}
ans.flight.6=filter(flights,dep_delay>=60,dep_delay-arr_delay>30)
```

    1. Departed between midnight and 6am (inclusive)

```{r}
ans.flight.7=filter(flights,between(dep_time,0,600))
```

2.  Another useful dplyr filtering helper is `between()`. What does it do?
    Can you use it to simplify the code needed to answer the previous 
    challenges? (Write the code using between() for subproblem 7 in the previous problem)

It is a shortcut for a closed interval. a<=x<=b.
```{r}
ans.flight.7=filter(flights,between(dep_time,0,600))
```

3.  How many flights have a missing `dep_time`? (Make a varible called "num.flights.missing.dep" for this number) What other variables are 
    missing? (Make a variable called "missing.var" containing the name of these missing varaibles) What might these rows represent?  
  
    Answer: 8255 flights have a missing `dep_time`. `arr_time` is missing for these observations as well so this most likely represents cancelled flights. `air_time`, `dep_delay`, `arr_delay` are also missing for these observations.
```{r}
flights.missing=flights%>% filter(is.na(dep_time))
(num.flights.missing.dep=flights%>% filter(is.na(dep_time)) %>% count())
```
    
4.  Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing?
    Why is `FALSE & NA` not missing? Can you figure out the general
    rule?  (`NA * 0` is a tricky counterexample!)   
      
    (Hint: Think about what NA means and think logically why the expressions above can be evaluated.)
    
    Answer:NA or TRUE is a logical answer which returns TRUE since TRUE is an option for the or statement.  NA^0 =1 because any number to the 0 power is 1. NA*0 is NA because NA could be any number. If the number is finite, then the answer would be 0.If the number is infinite, then the resultf the would be NaN. Since we dont know if the answer is 0 or NaN the result is NA.

```{r}
```

# Exercise 2

1.  How could you use `arrange()` to sort all missing values to the start?
    (Hint: use `is.na()`).  Make a variable called "missing.first" for this sorted tibble.
    
```{r}
missing.first <- arrange(flights, desc(is.na(dep_time)), dep_time)
```

2.  Sort `flights` to find the most delayed flights.(Make a variable called "delayed.sorted" for this sorted tibble).

```{r}
delayed.sorted <- arrange(flights,desc(dep_delay))
```

3. Sort `flights` to find the fastest flights (Make a variable called "fastest.flights" containing the rows with the fastest flights in terms of average speed).

```{r}
fastest.flights <- arrange(flights,air_time)
```

4.  Which flights travelled the longest? Which travelled the shortest? (Make a variable called "longest.flight" and "shortest.flight" for the rows with the longest and shortest flight)

```{r}
longest.flight <- arrange(flights,desc(distance))
shortest.flight <- arrange(flights,distance)
```

# Exercise 3
1.Brainstorm as many ways as possible to select `dep_time`, `dep_delay`,
    `arr_time`, and `arr_delay` from `flights`.
    
```{r}
select(flights,dep_time,dep_delay,arr_time,arr_delay)
select(flights,"dep_time","dep_delay","arr_time","arr_delay")
select(flights, 4, 5, 6, 9)
```

2.  What happens if you include the name of a variable multiple times in
    a `select()` call?  
    
    Answer:  It is only included once.
```{r}
```

3.  What does the `one_of()` function do? Why might it be helpful in conjunction
    with this vector?
    
    Answer:  You can store the variable names as vector and select all variables in the vector by using `one_of()` with `select()`
    ```{r}
    vars <- c("year", "month", "day", "dep_delay", "arr_delay")
    select(flights,one_of(vars))
    ```
    

# Exercise 4

1.  Currently `dep_time` and `sched_dep_time` are convenient to look at, but
    hard to compute with because they're not really continuous numbers. 
    Convert them to a more convenient representation of number of minutes
    since midnight. (Replace the variable "flights" with this tibble with converted dep_time and sched_dep_time)
    
```{r}
time_min=function(x) (x %/% 100 * 60 + x %% 100) %% 1440
flight_times <- flights%>% mutate(dep_time_min=time_min(dep_time),
                                sched_dep_min=time_min(sched_dep_time)
)
```

2.  Compare `air_time` with `arr_time - dep_time`. What do you expect to see?
    What do you see? What do you need to do to fix it?
      
    Answer:  They do not match up. Most likely because the time passes midnight which throws off the calculation.
```{r}
flight_time2 <- flight_times%>% mutate(arr_time_min=time_min(arr_time), air_time2=arr_time_min-dep_time_min)
```

3.  Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you
    expect those three numbers to be related?
    
    Answer: I would expect `dep_time` = `sched_dep_time` +`dep_delay`
    However this is not always the case.

```{r}
flight_time3 <- flight_time2 %>% transmute(dep_time_min,dep_time2=sched_dep_min+time_min(dep_delay))
```

4.  Find the 10 most delayed flights using a ranking function.(Name this variable "top.delayed" containing the rows) How do you want 
    to handle ties? Carefully read the documentation for `min_rank()`.
    
    Answer:  

```{r}
top.delayed <- flights%>% mutate(dep_delay_rank=min_rank(-dep_delay))%>%filter(dep_delay_rank<=10)%>% arrange(dep_delay_rank)%>%select(dep_delay_rank,dep_delay,everything())
top.delayed                                                                    
```

5.  What does `1:3 + 1:10` return? Why?  
  
    Answer:  It returns a warning: longer object length is not a multiple of shorter object length. This is because `R` is recycling the shorter length vector when preforming vector addition, but it does not go evenly into the longer length vector.
    
```{r}
```


# Exercise 5

1.  Brainstorm at least 3 different ways to assess the typical delay 
    characteristics of a group of flights. Consider the following scenarios:
    
    * A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of 
      the time.
      
    * A flight is always 10 minutes late.

    * A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of 
      the time.
      
    * 99% of the time a flight is on time. 1% of the time it's 2 hours late.
    
    Which is more important: arrival delay or departure delay?  
  (Make 3 similar statements as the ones above using the data we have)
    Answer: `dep_delay` is more important, if a plane doesnt leave then there is no need to check for an arrival delay.
    
```{r}
delay_info <-
  flights %>%
  group_by(flight) %>%
  summarise(n = n(),
            fifteen_early = mean(arr_delay == -15, na.rm = T),
            fifteen_late = mean(arr_delay == 15, na.rm = T),
            ten_always = mean(arr_delay == 10, na.rm = T),
            thirty_early = mean(arr_delay == -30, na.rm = T),
            thirty_late = mean(arr_delay == 30, na.rm = T),
            percentage_on_time = mean(arr_delay == 0, na.rm = T),
            twohours = mean(arr_delay > 120, na.rm = T))

delay_info %>%
  filter(fifteen_early == 0.5, fifteen_late == 0.5)


delay_info %>%
  filter(ten_always == 1)

delay_info %>%
  filter(thirty_early == 0.5 & thirty_late == 0.5)

delay_info %>%
  filter(percentage_on_time == 0.99 & twohours == 0.01)
```



2.  Look at the number of cancelled flights per day. Is there a pattern?
    Is the proportion of cancelled flights related to the average delay?

   Answer:  Looking at the graph the two appear to be related.
   
```{r}
  delay_cancel <- flights %>%
  mutate(canceled = (is.na(arr_delay) | is.na(dep_delay))) %>%
  group_by(year, month, day) %>%
  summarise(proportion_cancelled = mean(canceled),
            avg_dep_delay = mean(dep_delay, na.rm = TRUE))
```
```{r}
ggplot(delay_cancel,aes(x=avg_dep_delay,y=proportion_cancelled))+geom_point()+geom_smooth(method='lm',se=F)
```


3. Which carrier has the worst delays? 
  
  Answer: Frontier Airlines.
```{r}
flights %>% group_by(carrier)%>%summarise(mean_delay=mean(dep_delay, na.rm=T))%>%arrange(-mean_delay)
```

4.  What does the `sort` argument to `count()` do. When might you use it?  
  
    Answer: It sorts the results of count() by n. It is useful to sort count before using arrange. 
    
```{r}
```

# Exercise 6

1.  Which plane (`tailnum`) has the worst on-time record? (Make a variable called "worst.plane" for this plane tail number)


```{r}
(worst.plane <- flights%>% group_by(tailnum)%>%summarize(avgdelay=mean(arr_delay,na.rm=T))%>%filter(min_rank(desc(avgdelay)) <= 1))
```
2. For each destination, compute the total minutes of delay. (Make a tibble called "dest.delay

edmin" with these two columns) 
    
```{r}
(dest.delay <- flights%>% group_by(dest)%>% summarise(sum(arr_delay,na.rm=T)))
```

3.  Delays are typically temporally correlated: even once the problem that
    caused the initial delay has been resolved, later flights are delayed 
    to allow earlier flights to leave. Using `lag()`, explore how the delay
    of a flight is related to the delay of the immediately preceding flight.
(What proportion of delayed flights is caused by the delay of the immediately preceding flights)  
  
  Answer: 
  
```{r}
flights %>%
  select(year, month, day, hour, dest, dep_delay) %>%
  group_by(dest) %>%
  mutate(lag_delay = lag(dep_delay)) %>%
  arrange(dest) %>%
  filter(!is.na(lag_delay)) %>%
  summarize(cor = cor(dep_delay, lag_delay, use = "complete.obs"),
            n = n()) %>%
  arrange(desc(cor))
```


4. Find all destinations that are flown by at least two carriers. (Put these destinations into a variable called "popular.destinations")

```{r}
(popular.destinations <- flights%>% group_by(dest)%>%summarise(carriers=n_distinct(carrier))%>%filter(carriers>=2))
```

5.  For each plane, count the number of flights before the first delay 
    of greater than 1 hour. (Make a tibble called "plane.num.before.first.delay" with these two columns)
```{r}
(flights%>%arrange(tailnum, year, month,day)%>% group_by(tailnum)%>%mutate(hour_delay=dep_delay>60)%>%
  mutate(before_delay=cumsum(hour_delay))%>%
  filter(before_delay < 1)%>%
  count(sort=T))
```

